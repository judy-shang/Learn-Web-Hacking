gdb bomb

# 获取帮助
help

# 设置断点
break explode_bomb
break phase_1

# 开始运行
run

# 检查汇编 会给出对应的代码的汇编
disas 

# 查看寄存器内容
info registers

# 打印指定寄存器
print $rsp

# 每步执行
stepi

# 检查寄存器或某个地址
x/4wd $rsp

x/s $rsp #显示为字符串
x/16gx 0x402470 #显示某个内存的数据
x/100xb $rsp    #以16进制显示byte数据


mov    %fs:0x28,%rax
在x86_64上,不再使用分段寻址,但是FS和GS寄存器都可以用作基指针地址,以便访问特殊的操作系统数据结构.所以你所看到的是一个值,该值是在FS寄存器中保存的值的偏移量处加载的,而不是对FS寄存器内容的位操作.

特别是正在发生的事情是,FS:0x28在Linux上存储了一个特殊的标记栈保护值,并且代码正在执行堆栈保护检查.例如,如果您进一步查看代码,您将看到值FS:0x28存储在堆栈中,然后调用堆栈的内容并XOR执行原始值为的处理FS:0x28.如果两个值相等,这意味着零位已经设置,因为XOR两个相同的值导致零值,那么我们跳转到test例程,否则我们跳转到一个特殊函数,指示堆栈以某种方式被破坏,并且存储在堆栈上的sentinel值已更改.

如果使用GCC,可以禁用此功能

-fno-stack-protector